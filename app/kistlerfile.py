# AUTOGENERATED! DO NOT EDIT! File to edit: ditac-cable-problem-v0.7-nbdev.ipynb (unless otherwise specified).

__all__ = ['KistlerFile', 'create_inference_ready_sample']

# Cell
#export
# -----------------------------
# Make everything deterministic
# -----------------------------

import numpy as np
np.random.seed(2)

import torch
torch.manual_seed(2)
torch.backends.cudnn.deterministic = True
torch.backends.cudnn.benchmark = False

# -----------------------------

# Cell
import fastai
from fastcore import all
from fastai.tabular import *

from pathlib import Path

# Cell
import pandas as pd

# Cell
import matplotlib.pyplot as plt
import matplotlib.patches as patches

# Cell
import re
from random import randint, randrange, uniform

from io import StringIO

class KistlerFile:
    "Load, store, modify Kistler files for further ML analysis"
    _kf_max_time = None                 # this should be a static variable available across all KistlerFile instances
                                        # https://stackoverflow.com/questions/68645/are-static-class-variables-possible-in-python

    fname = None

    test_strings = None
    kistler_tokenized_tests = None

    kistler_lines = None
    test_string_regex = None

    df = resampled_df = None

    tests_status = None
    constraints  = None

    reason = None                       # reason why the "negativization" process failed

    min_kistler_lines = 280             # empirical value to say that the file was read ok (TODO change this)
    kistler_dataframe_line_offset = 278 # the force graph in Kistler files always starts at line 279
    min_y_negative_samples = -12.81173  # minimum y value for Kistler files (according to my whole DB)
    #min_x_cut_mm = 39.5

    def __init__(self, fname, csvdata=None, debug=False):
        self.fname = fname

        self.test_strings = []
        self.test_strings.append('EO-01;.*OK;')              # outcome of the first test
        self.test_strings.append('EO-02;.*OK;')              # outcome of the second test
        self.test_strings.append('EO-01;LINE-X;ABSOLUTE')    # description of the first test
        self.test_strings.append('EO-02;UNI-BOX;ABSOLUTE')   # description of the second test

        self.test_string_regex = ''

        self.tests_status = []
        self.constraints  = []

        # build the tests, we're not reading anything here...
        for idx, test_str in enumerate(self.test_strings):
            self.test_string_regex += test_str + '|'
            if debug:
                print(f'{test_str} - > {self.test_string_regex}')
        self.test_string_regex = self.test_string_regex[:-1]
        if debug:
            print(f'{self.test_string_regex}\n')

        self.read(fname, debug=debug)              # read the actual graph
        self.read_tests(fname, debug=debug)        # read the test condition lines (usually 4)
        self.tokenize_tests(debug=debug)           # parse the tests you just read

    def is_ok(self, debug=False):
        "Test if _EVERY_ tests say the force graph is ok"
        if debug:
            print(f'{self.tests_status = }')
        for test in self.tests_status:
            if test == 'NOK':
                return False
        return True

    def is_this_constraint_ok(self, idx, debug=False):
        "Test if _JUST THIS_ test says the force graph is ok"
        if debug:
            print(f'{self.tests_status = }')
        tests_status = self.tests_status
        if debug:
            print(f'{tests_status = }')
        if tests_status == 'NOK':
            return False
        return True

    # read the dataframe with the real sensor signal
    def read(self, fname, debug=False):
        "Read the Kistler file into a Pandas DataFrame"
        if debug:
            print(f'Opening file: {fname}')
        self.df = pd.read_csv(fname, skiprows=self.kistler_dataframe_line_offset, sep=';', decimal=',')
        if debug:
            print(self.df.head())

    # Add a new last row, copying the previous one, but modifying just the timestamp in seconds
    # to match the one from the "longest" KistlerFile (i.e. the one that ends at the latest timestamp)
    def add_max_time_as_last_row(self, new_df, debug=False):
        '''Add a new row to the DataFrame, copying the previous one, but modifying the timestamp
        to match the one from the "longest" KistlerFile. This is tricky (because we must necessarily
        read all the files we want to process) but needed by resample()'''
        new_data = pd.DataFrame(new_df[-1:].values, index=[len(new_df)], columns=new_df.columns)
        if debug:
            print(f'{new_data} = ')
        new_data['s'] = KistlerFile._kf_max_time
        new_df = new_df.append(new_data)
        if debug:
            print(f'{new_df} = ')

    def resample(self, debug=False):
        "Resample the DataFrame to produce a DataFrame with the same number of columns as ALL the other DataFrames"
        new_df = self.df
        if KistlerFile._kf_max_time is not None:
            self.add_max_time_as_last_row(new_df, debug=debug)
        new_df['td'] = pd.to_timedelta(new_df['s'], 's')
        if debug:
            print(f'{len(new_df["td"])}')

        if debug:
            from IPython.display import display
            with pd.option_context('display.max_rows', 100, 'display.max_columns', 10):
                display(new_df) #need display to show the dataframe when using with in jupyter

        #pd.set_option('display.max_rows', 100)
        self.resampled_df = new_df.set_index(new_df['td']).resample('5ms').mean().fillna(method='ffill')
        if debug:
            with pd.option_context('display.max_rows', 300, 'display.max_columns', 10):
                print(f'Resampled len: {len(self.resampled_df)}')
                display(self.resampled_df) #need display to show the dataframe when using with in jupyter

    def resample_kn(self, debug=False):
        "Deprecated, don't use"
        new_df = self.df
        new_df['td_kN'] = pd.to_timedelta(new_df['kN'], 's')

        if debug:
            from IPython.display import display
            with pd.option_context('display.max_rows', 100, 'display.max_columns', 10):
                display(new_df) #need display to show the dataframe when using with in jupyter

        #pd.set_option('display.max_rows', 100)
        self.resampled_df = new_df.set_index(new_df['td_kN']).resample('5ms').mean().fillna(method='ffill')
        if debug:
            with pd.option_context('display.max_rows', 300, 'display.max_columns', 10):
                print(f'Resampled len: {len(self.resampled_df)}')
                display(self.resampled_df) #need display to show the dataframe when using with in jupyter

    def draw_constraints(self, ax, debug=False):
        "Show constraint (i.e. tests) on the graph (usually just one box and a line)"
        for idx, constraint_tuple in enumerate(self.constraints):
            constraint_color = (('red', 'xkcd:light red') if not self.is_this_constraint_ok(idx) else ('green', 'xkcd:light green'))
            if debug:
                print(f'{constraint_tuple = } - {[itm for idx,itm in enumerate(constraint_tuple)]}')
            type_str, x_start, x_end, y_start, y_end = constraint_tuple
            if type_str == 'BOX':          # constraint_to_tuple() - ['BOX', '37,7', '38,2', '0,80', '6,75']
                # Create a Rectangle patch
                rect = patches.Rectangle((x_start, y_start), x_end-x_start, y_end-y_start, linewidth=1, edgecolor=constraint_color[0], facecolor=constraint_color[1])
                # Add the patch to the Axes
                ax.add_patch(rect)
            if type_str == 'LINE':         # constraint_to_tuple() - ['LINE', '38,7', '41,0', '6,75', '0']
                # Create a Rectangle patch
                rect = patches.Rectangle((x_start, y_start), x_end-x_start, y_end-y_start, linewidth=1, edgecolor=constraint_color[0], facecolor=constraint_color[1])
                # Add the patch to the Axes
                ax.add_patch(rect)

    def draw_resampled_graph(self, ax, debug=False):
        "Plot both graph and constraints (= tests) of _JUST_ the resampled DataFrame"
        color = ('red' if not self.is_ok() else 'green')
        if self.resampled_df is None:
            self.resample(debug=True)
        self.resampled_df.plot(kind='line', ax=ax, x='mm', y='kN', color=color)

        self.draw_constraints(ax)

    def graph(self, resampled=False, both=False, debug=False, filename=None):
        "Plot both graph and constraints (= tests) of both the original and resampled DataFrame"

        if both:
            fig, (ax1, ax2) = plt.subplots(2)
            fig.set_size_inches(10, 10)
            ax = ax1
        else:
            plt.figure()
            ax = plt.gca()

        color = ('red' if not self.is_ok() else 'green')
        if not resampled or both:
            self.df.plot(kind='line', ax=ax, x='mm', y='kN', color=color)
        else:
            if self.resampled_df is None:
                self.resample(debug=debug)
            self.resampled_df.plot(kind='line', ax=ax, x='mm', y='kN', color=color)

        self.draw_constraints(ax)

        if both:
            ax = ax2
            self.draw_resampled_graph(ax)

        if filename is not None:
            plt.savefig(filename, bbox_inches='tight')
        else:
            plt.show()

    # read just the tests
    def read_tests(self, fname, debug=False):
        "Open the source file and read the constraint lines"
        if type(fname) == str:
            with open(fname, 'r') as kistler_file:
                self.kistler_lines = kistler_file.readlines()
        elif type(fname) == StringIO:
                fname.seek(0)
                self.kistler_lines = fname.readlines()
        else:
            assert('Unknown data source provided')

        if debug:
            print(f'Read a total of {len(self.kistler_lines)} lines')

        assert len(self.kistler_lines) >= self.min_kistler_lines, \
                f'kistler_lines: {len(self.kistler_lines)} >= min_kistler_lines: {self.min_kistler_lines} in file: {self.fname}'

    def constraint_to_tuple(self, type_str, x_start, x_end, y_start, y_end, debug=False):
        "Convert the constraints as read from the file to a tuple"
        constraint_tuple = [type_str, x_start, x_end, y_start, y_end]
        constraint_tuple = [x if x != '' else constraint_tuple[i-1] for i,x in enumerate(constraint_tuple)]
        if debug:
            print(f'constraint_to_tuple() - {constraint_tuple}')
        constraint_tuple = [float(x.replace(',','.')) if i != 0 else x for i,x in enumerate(constraint_tuple)]
        return constraint_tuple

    # parse a constraint line
    def get_constraint(self, line, debug=False):
        "Parse one constraint line read from file"
        if not 'LINE' in line and not 'BOX' in line:
            return (None, None, None, None, None)
        tokens = line.split(';')
        if debug:
            print(f'get_constraint() {tokens = }')
        if 'LINE' in line:
            # e.g. EO-01;LINE-X;ABSOLUTE;-;38,7;41,0;6,75;;BELOW;NONE;ANY;+50%;+0%;;;;;
            x_start = tokens[4] # 38.7
            x_end   = tokens[5] # 41
            y_start = tokens[6] # 6.75
            y_end   = tokens[7] # ''
            constraint_tuple = self.constraint_to_tuple('LINE', x_start, x_end, y_start, y_end)
            return constraint_tuple
        if 'BOX' in line:
            # e.g. EO-02;UNI-BOX;ABSOLUTE'> -> EO-02;UNI-BOX;ABSOLUTE;-;37,7;38,2;0,80;6,75;LEFT;RIGHT;ANY;+50%;+50%;;;;;
            x_start = tokens[4] # 37.7
            x_end   = tokens[5] # 38.2
            y_start = tokens[6] # 0.80
            y_end   = tokens[7] # 6.75
            constraint_tuple = self.constraint_to_tuple('BOX', x_start, x_end, y_start, y_end)
            return constraint_tuple

    # parse the tests and understand the outcome
    def tokenize_tests(self, debug=False):
        "Parse the constraint lines inside the Kistler file and understand the outcome of the test"
        self.kistler_tokenized_tests = dict()
        for line in self.kistler_lines:
            match = re.search(self.test_string_regex, line)
            if match:
                if debug:
                    print(f'{match} -> {line}')

                if not 'LINE' in line and not 'BOX' in line:
                    test_outcome = 'NOK' if 'NOK' in line else 'OK'
                    if debug:
                        print(f'{test_outcome = }')
                    self.tests_status.append(test_outcome)
                else:
                    self.constraints.append(self.get_constraint(line))

                self.kistler_tokenized_tests[match.group(0)] = []
                for token in line.split(';'):
                    if token != '' and token != '\n':
                        self.kistler_tokenized_tests[match.group(0)].append(token)
        if debug:
            print(40*'-')
            print(f'Kistler tokenized tests has {len(self.kistler_tokenized_tests)} elements: {self.kistler_tokenized_tests}')
            print(40*'-')
            print(f'{self.constraints = }')

        #assert len(self.kistler_tokenized_tests) == 4, f'kistler_tokenized_tests: {len(self.kistler_tokenized_tests)} != 4 in file: {self.fname}'
        if len(self.kistler_tokenized_tests) != 4:
            print(f'WARNING: kistler_tokenized_tests: {len(self.kistler_tokenized_tests)} != 4 in file: {self.fname}')

    def create_negative_sample(self, add_noise=True, max_noise=0.05, debug=False):
        '''Transform this "positive" (i.e. with a good force graph) KistlerFile into a negative sample
        (e.g. one that clearly suffers from "the cable problem")'''

        # if nobody ever called self.resample() until now, we do it right now
        if self.resampled_df is None:
            self.resample(debug=debug)

        if not self.is_ok() or kf.resampled_df['kN'].min() < 0:
            # ok, the first part of this condition just tells us to ignore NOK files
            # (because they can be null or whatever). The second part tells us to also
            # ignore those samples which already are "negative samples" (e.g. early samples
            # in the short "cable-problem" time series that are mostly good except a sudden
            # drop in kN at the end of the graph)
            if debug:
                print('Unable to corrupt the resampled DataFrame of an already NOK (negative) sample...')
            self.reason = 'Already NOK sample'
            return False

        noise = None
        if add_noise:
            noise = np.random.normal(-max_noise, max_noise, len(self.resampled_df))

        if debug:
            print(f'{len(self.resampled_df) = }')
            print(f'{self.resampled_df["mm"][-1] = }')

        # ok, normally (for our 1-day scenario) the best approach would be to cut at 40.0 exact
        # but doing this way, literally thousand of samples can't be negativized because they
        # end at 39.xyz. So the easy fix is to cut at self.resampled_df['mm'][-1]-1.0
        x_cut_mm = uniform(self.resampled_df['mm'][-1]-1.0, self.resampled_df['mm'][-1]) # choose where to cut along x axis
        y_valley = uniform(-1.0, self.min_y_negative_samples)              # choose the "depth" of the valley (minimum)
                                                                           # along the y axis (kN)

        transplant_df = self.resampled_df.loc[self.resampled_df['mm'] >= x_cut_mm].copy()

        if debug:
            print(f'{x_cut_mm = }')
            print(f'{y_valley = }')
            print(f'{transplant_df}')
            print(f'{self.fname.name}') # ok, this file here:
                                        # Part_maXYmos7_MP-001_2020-12-05_12-07-17_1_2012051151484057_______OK.csv
                                        # is quite problematic in many ways... let's just skip it for the moment
        if transplant_df.empty:
            print(f'WARNING: can\'t negativize this sample, the intermediate DataFrame is empty...')
            self.reason = 'Intermediate DF empty'
            return False

        head_kn = transplant_df['kN'][0]                               # just get the head, then interpolate
                                                                       # linearly toward the minimum
        transplant_df['kN'] = np.NaN
        transplant_df['kN'][0]  = head_kn
        transplant_df['kN'][-1] = y_valley

        if debug:
            print(f'{head_kn = }')

            print(f'{transplant_df["kN"][-1] = }')
            print(f'{transplant_df = }')

        new_kn = transplant_df["kN"]
        new_kn = new_kn.interpolate(method='index')

        if debug:
            print(f'{new_kn = }')

        self.resampled_df.loc[self.resampled_df['mm'] >= x_cut_mm, 'kN'] = new_kn.values

        if add_noise:
            self.resampled_df.loc[:, 'kN'] = self.resampled_df['kN'] + noise

        if debug:
            print(f'{self.tests_status = }')

        # we need to test even for this kind of things, because a very few files are "strange" and different
        # from all the others (e.g. Part_maXYmos7_MP-001_2020-12-18_16-46-40_1_2012181638069146_______OK.csv
        # that has two tests, both OK, but in position 2 and 3 instead of 1 and 2)
        if len(self.tests_status) >= 2:
            # and now... the finishing touch! set the second test status to NOK to have a nice red graph
            self.tests_status[1] = 'NOK'
        else:
            # just throw it away, it should be better...
            self.reason = 'Test status problem'
            return False

        return True


# Cell
def create_inference_ready_sample(kf, debug=False):
    test_list = []
    test_list.append(kf.resampled_df['kN'].values)
    if debug:
        print(f'{len(test_list)} - {test_list}')
    test_df = pd.DataFrame(test_list)
    if debug:
        print(f'{len(test_df)} - {test_df}')
    sample = test_df.iloc[0]
    if debug:
        print(f'{len(sample)} - {sample}')
    return sample
